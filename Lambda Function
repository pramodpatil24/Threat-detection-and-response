import json
import boto3
import os

ec2 = boto3.client('ec2')
sns = boto3.client('sns')

# Environment variables to be set on Lambda:
# ISOLATE_SG_ID: Security Group ID used to isolate compromised instances (must restrict in/out traffic)
# SNS_TOPIC_ARN: SNS topic ARN for sending notifications (optional but recommended)

ISOLATE_SG_ID = os.environ.get('ISOLATE_SG_ID')
SNS_TOPIC_ARN = os.environ.get('SNS_TOPIC_ARN')

# List of GuardDuty finding types to remediate
REMEDIATION_FINDING_TYPES = [
    "UnauthorizedAccess:EC2/SSHBruteForce",
    "Recon:EC2/PortProbeEMRUnprotectedPort",
    "Recon:EC2/PortProbeUnprotectedPort",
    "Recon:EC2/Portscan",
    "Behavior:EC2/TrafficVolumeUnusual",
    "Backdoor:EC2/DenialOfService.Dns",
    "Backdoor:EC2/DenialOfService.Tcp",
    "Backdoor:EC2/DenialOfService.Udp",
    "Backdoor:EC2/DenialOfService.UdpOnTcpPorts",
    "Backdoor:EC2/DenialOfService.UnusualProtocol",
    "Backdoor:EC2/Spambot",
    "Behavior:EC2/NetworkPortUnusual"
]

def lambda_handler(event, context):
    print("Received event:", json.dumps(event))

    finding = event.get('detail')
    if not finding:
        print("No 'detail' found in event.")
        return

    finding_type = finding.get('type')
    if finding_type not in REMEDIATION_FINDING_TYPES:
        print(f"Finding type {finding_type} is not in remediation list; skipping.")
        return

    # Extract instance ID
    instance_id = (
        finding.get('resource', {})
        .get('instanceDetails', {})
        .get('instanceId')
    )
    if not instance_id:
        print("No EC2 instance ID found in event; skipping remediation.")
        return

    print(f"Extracted instance ID: {instance_id}")

    # Extract attacker IPs
    attacker_ips = extract_attacker_ips(finding)
    print(f"Attacker IPs extracted: {attacker_ips}")

    try:
        # Describe the instance to get current security groups
        response = ec2.describe_instances(InstanceIds=[instance_id])
        reservations = response.get('Reservations', [])
        if not reservations:
            print(f"Instance {instance_id} not found.")
            return

        instance = reservations[0]['Instances'][0]
        current_sgs = [sg['GroupId'] for sg in instance.get('SecurityGroups', [])]
        print(f"Instance {instance_id} current security groups: {current_sgs}")

        if not ISOLATE_SG_ID:
            print("ISOLATE_SG_ID environment variable not set; cannot isolate instance.")
            return

        # Step 1: Replace security groups with isolation security group
        ec2.modify_instance_attribute(InstanceId=instance_id, Groups=[ISOLATE_SG_ID])
        print(f"Replaced security groups on instance {instance_id} with isolation SG {ISOLATE_SG_ID}")

        # Step 2: Tag instance as Compromised
        ec2.create_tags(Resources=[instance_id], Tags=[{'Key': 'Compromised', 'Value': 'True'}])
        print(f"Tagged instance {instance_id} as Compromised.")

        # Step 3: Block attacker IPs in Security Groups
        for ip in attacker_ips:
            block_ip_in_security_groups(ip)

        # Step 4: Block attacker IPs in Network ACLs
        for ip in attacker_ips:
            block_ip_in_network_acls(ip)

        # Step 5: Send SNS notification
        if SNS_TOPIC_ARN:
            message = (
                f"Instance {instance_id} has been isolated due to GuardDuty finding {finding.get('id')} "
                f"of type {finding_type}.\n"
                f"Original Security Groups: {current_sgs}\n"
                f"Attacker IP(s): {attacker_ips}\n"
                f"Full Finding Details: {json.dumps(finding, indent=2)}"
            )
            sns.publish(
                TopicArn=SNS_TOPIC_ARN,
                Message=message,
                Subject="GuardDuty Alert: Instance Isolated"
            )
            print(f"SNS notification sent for instance {instance_id}.")

    except Exception as e:
        print(f"Exception during remediation: {e}")
        return {
            'statusCode': 500,
            'body': f"Error during remediation: {str(e)}"
        }

    return {
        'statusCode': 200,
        'body': f"Instance {instance_id} isolated and attacker IP(s) blocked."
    }


def extract_attacker_ips(finding):
    """
    Extract attacker IP addresses from various GuardDuty finding types.
    Returns a list of unique IPs (can be empty).
    """
    ips = set()
    service_action = finding.get('service', {}).get('action', {})

    # Extract from portProbeAction (e.g., for Portscan)
    port_probe_action = service_action.get('portProbeAction')
    if port_probe_action:
        port_probe_details = port_probe_action.get('portProbeDetails', [])
        for detail in port_probe_details:
            ip = detail.get('remoteIpDetails', {}).get('ipAddressV4')
            if ip:
                ips.add(ip)

    # Extract from networkConnectionAction (e.g., for SSH brute force)
    net_conn_action = service_action.get('networkConnectionAction')
    if net_conn_action:
        ip = net_conn_action.get('remoteIpDetails', {}).get('ipAddressV4')
        if ip:
            ips.add(ip)

    # Additional extraction logic can be added here for other finding types

    return list(ips)


def block_ip_in_security_groups(ip):
    """
    Removes any ingress rules that allow SSH (port 22) from the attacker IP in all security groups.
    """
    try:
        sgs = ec2.describe_security_groups()['SecurityGroups']
        for sg in sgs:
            for perm in sg.get('IpPermissions', []):
                if perm.get('FromPort') == 22 and perm.get('ToPort') == 22 and perm.get('IpProtocol') == 'tcp':
                    for ip_range in perm.get('IpRanges', []):
                        if ip_range.get('CidrIp') == f"{ip}/32":
                            print(f"Revoking ingress rule from SG {sg['GroupId']} for IP {ip}")
                            try:
                                ec2.revoke_security_group_ingress(
                                    GroupId=sg['GroupId'],
                                    IpProtocol='tcp',
                                    FromPort=22,
                                    ToPort=22,
                                    CidrIp=f"{ip}/32"
                                )
                                print(f"Successfully revoked ingress on SG {sg['GroupId']} for IP {ip}")
                            except Exception as e:
                                print(f"Error revoking ingress on SG {sg['GroupId']} for IP {ip}: {e}")
    except Exception as e:
        print(f"Error describing or modifying security groups: {e}")


def block_ip_in_network_acls(ip):
    """
    Adds a DENY rule for the attacker IP to all non-default Network ACLs blocking TCP port 22 inbound.
    Note: This uses fixed RuleNumber 200; adjust as per your environment to avoid conflicts.
    """
    try:
        nacls = ec2.describe_network_acls()['NetworkAcls']
        for nacl in nacls:
            if not nacl['IsDefault']:
                # Check if rule already exists
                existing_rule = any(
                    entry.get('CidrBlock') == f"{ip}/32" and
                    entry.get('RuleAction') == 'deny' and
                    entry.get('PortRange', {}).get('From') == 22 and
                    entry.get('PortRange', {}).get('To') == 22 and
                    not entry.get('Egress', True)
                    for entry in nacl.get('Entries', [])
                )
                if existing_rule:
                    print(f"NACL {nacl['NetworkAclId']} already contains deny rule for {ip}/32 port 22")
                    continue

                try:
                    ec2.create_network_acl_entry(
                        NetworkAclId=nacl['NetworkAclId'],
                        RuleNumber=200,  # Warning: ensure this doesn't conflict with existing rules
                        Protocol='6',  # TCP
                        RuleAction='deny',
                        Egress=False,
                        CidrBlock=f"{ip}/32",
                        PortRange={'From': 22, 'To': 22}
                    )
                    print(f"Added deny NACL entry for IP {ip} on NACL {nacl['NetworkAclId']}")
                except Exception as e:
                    print(f"Error adding deny rule on NACL {nacl['NetworkAclId']} for IP {ip}: {e}")

    except Exception as e:
        print(f"Error describing or modifying Network ACLs: {e}")
